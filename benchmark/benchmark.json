{
    "benchmark_metadata": {
        "version": "2.7",
        "total_levels": 5,
        "points_per_level": 20,
        "total_exam_points": 100,
        "grading_rule": "If multiple deductions share the same exclusivity_group, only apply the deduction with the highest value. Logic Score = Max(0, 16 - deductions). Syntax Score = Max(0, 4 - deductions)."
    },
    "levels": [
        {
            "id": "L1_VERY_EASY",
            "title": "Basic Arithmetic (Temperature)",
            "total_points": 20,
            "problem_description": "Write a function 'float toFahrenheit(float celsius)' that converts Celsius to Fahrenheit using the formula: (Celsius * 9/5) + 32.",
            "explicit_instructions": ["Function name: 'toFahrenheit'", "Return type: float"],
            "test_cases": [
                {"input": "0", "expected_output": "32.0", "description": "Freezing point"},
                {"input": "100", "expected_output": "212.0", "description": "Boiling point"},
                {"input": "37.5", "expected_output": "99.5", "description": "Decimal precision check"}
            ],
            "reference_solution": "float toFahrenheit(float celsius) { return (celsius * 9.0 / 5.0) + 32.0; }",
            "grading_rubric": {
                "logic_points": 16,
                "syntax_points": 4,
                "hidden_deductions": [
                    {"condition": "Used integer division (9/5)", "deduct": 5, "exclusivity_group": "formula_error"},
                    {"condition": "Wrong formula logic", "deduct": 14, "exclusivity_group": "formula_error"},
                    {"condition": "Incorrect return type", "deduct": 2, "exclusivity_group": "syntax_error"}
                ]
            },
            "sample_answers": [
                {
                    "id": "L1_S1",
                    "label": "Integer Trap",
                    "score": 15,
                    "code": "float toFahrenheit(float c) { return (c * (9/5)) + 32; }",
                    "human_rationale": "15/20. Good structure, but 9/5 evaluates to 1. Deducted 5 logic points."
                },
                {
                    "id": "L1_S2",
                    "label": "Wrong Formula",
                    "score": 6,
                    "code": "float toFahrenheit(float c) { return (c * 5/9) + 32; }",
                    "human_rationale": "6/20. Used wrong formula, resulting in incorrect conversions."
                },
                {
                    "id": "L1_S3",
                    "label": "Wrong Return Type",
                    "score": 18,
                    "code": "int toFahrenheit(float c) { return (c * 9.0 / 5.0) + 32.0; }",
                    "human_rationale": "18/20. Correct logic but wrong return type."
                }
            ]
        },
        {
            "id": "L2_EASY",
            "title": "Looping Logic (Factorial)",
            "total_points": 20,
            "problem_description": "Write a program that takes an integer N and prints the factorial of N.",
            "explicit_instructions": ["Use cin and cout"],
            "test_cases": [
                {"input": "5", "expected_output": "120", "description": "Standard factorial"},
                {"input": "0", "expected_output": "1", "description": "Edge case: 0!"},
                {"input": "13", "expected_output": "6227020800", "description": "Overflow check (requires long long)"}
            ],
            "reference_solution": "#include <iostream>\nusing namespace std;\nint main() {\n    int n; if (!(cin >> n) || n < 0) return 0;\n    long long fact = 1;\n    for(int i = 1; i <= n; i++) fact *= i;\n    cout << fact; return 0;\n}",
            "grading_rubric": {
                "logic_points": 16,
                "syntax_points": 4,
                "hidden_deductions": [
                    {"condition": "Used 'int' instead of 'long long'", "deduct": 2, "exclusivity_group": "data_type"},
                    {"condition": "Fails N=0 (result should be 1)", "deduct": 4, "exclusivity_group": "edge_case"},
                    {"condition": "Starts factorial at 0", "deduct": 12, "exclusivity_group": "math_logic"},
                    {"condition": "Loop starts from 0", "deduct": 12, "exclusivity_group": "math_logic"},
                    {"condition": "Loop condition incorrect (i < n)", "deduct": 4, "exclusivity_group": "loop_bounds"},
                    {"condition": "Prints result inside loop", "deduct": 3, "exclusivity_group": "io_format"},
                    {"condition": "Negative input not handled", "deduct": 1, "exclusivity_group": "validation"},
                    {"condition": "Fails to read input using cin", "deduct": 16, "exclusivity_group": "io_logic"}
                ]
            },
            "sample_answers": [
                 {
                   "id": "L2_S1",
                   "label": "Negative input not handled",
                   "score": 19,
                   "code": "#include <iostream>\nusing namespace std;\nint main() {\n    int n; cin >> n;\n    long long fact = 1;\n    for(int i = 1; i <= n; i++) fact *= i;\n    cout << fact;\n    return 0;\n}",
                   "human_rationale": "19/20. Negative input not handled."
               },
                {
                    "id": "L2_S2",
                    "label": "Starts Factorial at 0",
                    "score": 8,
                    "code": "#include <iostream>\nusing namespace std;\nint main() {\n    int n; cin >> n; long long fact = 0; for(int i = 1; i <= n; i++) fact *= i; cout << fact; return 0;\n}",
                    "human_rationale": "8/20. Syntax is fine, but result is always 0. Major logic failure."
                },
               {
                   "id": "L2_S3",
                   "label": "Loop off-by-one",
                   "score": 16,
                   "code": "#include <iostream>\nusing namespace std;\nint main() { int n; cin >> n; long long fact = 1; for(int i=1;i<n;i++) fact*=i; cout<<fact; return 0; }",
                   "human_rationale": "16/20. Misses last multiplication (i<n). Deducted 4 points for logic."
                }

            ]
        },
        {
            "id": "L3_MEDIUM",
            "title": "String Manipulation (Palindrome)",
            "total_points": 20,
            "problem_description": "Write a function 'bool isPalindrome(string s)' (Case-sensitive).",
            "explicit_instructions": ["Case-sensitive", "Empty string = true"],
            "test_cases": [
                {"input": "\"racecar\"", "expected_output": "true", "description": "Standard palindrome"},
                {"input": "\"Racecar\"", "expected_output": "false", "description": "Case-sensitivity check"},
                {"input": "\"\"", "expected_output": "true", "description": "Empty string check"}
            ],
            "reference_solution": "#include <string>\n#include <algorithm>\nusing namespace std;\nbool isPalindrome(string s) {\n    if (s.empty()) return true;\n    string r = s; reverse(r.begin(), r.end());\n    return s == r;\n}",
            "grading_rubric": {
                "logic_points": 16,
                "syntax_points": 4,
                "hidden_deductions": [
                    {"condition": "Logic fails on odd-length strings", "deduct": 8, "exclusivity_group": "algorithm"},
                    {"condition": "Made it case-insensitive", "deduct": 4, "exclusivity_group": "instruction_violation"},
                    {"condition": "Does not handle empty string", "deduct": 3, "exclusivity_group": "edge_case"},
                    {"condition": "Off-by-one error in loop bounds", "deduct": 4, "exclusivity_group": "algorithm"},
                    {"condition": "Always returns false", "deduct": 16, "exclusivity_group": "algorithm"},
                    {"condition": "Wrong return type", "deduct": 2, "exclusivity_group": "syntax_error"}
                ]
            },
            "sample_answers": [
                {
                    "id": "L3_S2",
                    "label": "Off-by-One Error",
                    "score": 16,
                    "code": "bool isPalindrome(string s) {\n    int n = s.size();\n    for(int i = 0; i <= n/2; i++) {\n        if(s[i] != s[n - i - 1]) return false;\n    }\n    return true;\n}",
                    "human_rationale": "16/20. Logic is mostly correct, but the loop goes one step too far."
                }
            ]
        },
        {
            "id": "L4_HARD",
            "title": "Recursion (Fibonacci)",
            "total_points": 20,
            "problem_description": "Write a recursive function 'int fib(int n)'.",
            "explicit_instructions": ["Must use recursion", "No loops"],
            "test_cases": [
                {"input": "0", "expected_output": "0", "description": "Base case 1"},
                {"input": "1", "expected_output": "1", "description": "Base case 2"},
                {"input": "6", "expected_output": "8", "description": "Standard recursive step"}
            ],
            "reference_solution": "int fib(int n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n    return fib(n-1) + fib(n-2);\n}",
            "grading_rubric": {
                "logic_points": 16,
                "syntax_points": 4,
                "hidden_deductions": [
                    {"condition": "Missing base cases", "deduct": 10, "exclusivity_group": "instruction_violation"},
                    {"condition": "Used iterative loop", "deduct": 12, "exclusivity_group": "instruction_violation"},
                    {"condition": "Incorrect recursive relation", "deduct": 10, "exclusivity_group": "instruction_violation"},
                    {"condition": "Wrong return type", "deduct": 2, "exclusivity_group": "syntax_error"}
                ]
            },
            "sample_answers": [
    {
        "id": "L4_S1",
        "label": "Missing Base Case Trap",
        "score": 8,
        "code": "int fib(int n) {\n    return fib(n-1) + fib(n-2);\n}",
        "human_rationale": "8/20. Logic score: 16 - 12 (Base Case) = 4. Syntax: 4. Total: 8. The formula is correct, but it will cause a Stack Overflow crash because it never stops."
    },
    {
        "id": "L4_S2",
        "label": "Perfect Recursive Solution",
        "score": 20,
        "code": "int fib(int n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n    return fib(n-1) + fib(n-2);\n}",
        "human_rationale": "20/20. Correct logic, handles base cases, and uses recursion as requested."
    },
    {
        "id": "L4_S3",
        "label": "Iterative Violation",
        "score": 10,
        "code": "int fib(int n) {\n    int a = 0, b = 1, c;\n    if(n==0) return 0;\n    for(int i=2; i<=n; i++) {\n        c = a + b; a = b; b = c;\n    }\n    return b;\n}",
        "human_rationale": "10/20. The math is 100% correct, but the student was strictly told 'No loops'. Logic: 16 - 10 (Instruction Violation) = 6. Syntax: 4. Total: 10."
    },
    {
        "id": "L4_S4",
        "label": "Formula Error",
        "score": 6,
        "code": "int fib(int n) {\n    if (n <= 1) return n;\n    return fib(n-1) + fib(n-1);\n}",
        "human_rationale": "6/20. Syntax is fine. Base cases are fine. However, adding (n-1) to (n-1) is not the Fibonacci sequence. Logic: 16 - 14 (Incorrect Relation) = 2. Syntax: 4. Total: 6."
    }
]
          
        },
        {
            "id": "L5_VERY_HARD",
            "title": "Memory Safety (Linked List)",
            "total_points": 20,
            "problem_description": "Write a function 'Node* insertEnd(Node* head, int value)' to append a node.",
            "explicit_instructions": ["Return new head", "Use dynamic memory (new)"],
            "test_cases": [
                {"input": "head=NULL, val=10", "expected_output": "New node with 10", "description": "Empty list handling"},
                {"input": "head=[5], val=15", "expected_output": "[5, 15]", "description": "Existing list append"}
            ],
            "reference_solution": "struct Node { int data; Node* next; };\nNode* insertEnd(Node* head, int val) {\n    Node* nn = new Node{val, nullptr};\n    if(!head) return nn;\n    Node* t = head; while(t->next) t = t->next;\n    t->next = nn; return head;\n}",
            "grading_rubric": {
                "logic_points": 16,
                "syntax_points": 4,
                "hidden_deductions": [
                    {"condition": "Crash when head is NULL", "deduct": 6, "exclusivity_group": "safety"},
                    {"condition": "Memory allocation failure", "deduct": 16, "exclusivity_group": "allocation"},
                    {"condition": "Does not return new head", "deduct": 5, "exclusivity_group": "signature"},
                    {"condition": "Fails to use 'new' for node creation", "deduct": 12, "exclusivity_group": "allocation"},
                    {"condition": "Memory leak/Lost pointer", "deduct": 6, "exclusivity_group": "safety"},
                    {"condition": "Infinite loop", "deduct": 14, "exclusivity_group": "safety"}
                ]
            },
            "sample_answers": [
    {
        "id": "L5_S1",
        "label": "Null Head Crash Trap",
        "score": 14,
        "code": "Node* insertEnd(Node* head, int v) {\n    Node* temp = head;\n    while(temp->next != nullptr) temp = temp->next;\n    temp->next = new Node(v);\n    return head;\n}",
        "human_rationale": "14/20. Logic works for existing lists. However, it crashes if the list is empty because it doesn't check 'if(!head)'. Logic: 16 - 6 (Safety) = 10. Syntax: 4. Total: 14."
    },
    {
        "id": "L5_S2",
        "label": "Perfect Solution",
        "score": 20,
        "code": "Node* insertEnd(Node* head, int val) {\n    Node* nn = new Node{val, nullptr};\n    if(!head) return nn;\n    Node* t = head; \n    while(t->next) t = t->next;\n    t->next = nn; \n    return head;\n}",
        "human_rationale": "20/20. Correct allocation, safe for empty lists, and correct traversal."
    },
    {
        "id": "L5_S3",
        "label": "Wrong Return Contract",
        "score": 15,
        "code": "Node* insertEnd(Node* head, int val) {\n    Node* nn = new Node{val, nullptr};\n    if(!head) return nn;\n    Node* t = head; while(t->next) t = t->next;\n    t->next = nn;\n    return nn; // Error: Returns the end, not the head\n}",
        "human_rationale": "15/20. Implementation is good, but it returns the new node instead of the head of the list. Logic: 16 - 5 (Signature) = 11. Syntax: 4. Total: 15."
    }
]
            
        }
    ]
}

