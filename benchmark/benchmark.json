{
    "benchmark_metadata": {
        "version": "2.8",
        "total_levels": 5,
        "points_per_level": 20,
        "total_exam_points": 100,
        "grading_rule": "If multiple deductions share the same exclusivity_group, only apply the deduction with the highest value. Logic Score = Max(0, 16 - deductions). Syntax Score = Max(0, 4 - deductions)."
    },
    "levels": [
        {
            "id": "L1_VERY_EASY",
            "title": "Basic Arithmetic (Temperature)",
            "total_points": 20,
            "problem_description": "Write a function 'float toFahrenheit(float celsius)' that converts Celsius to Fahrenheit using the formula: (Celsius * 9/5) + 32.",
            "explicit_instructions": ["Function name: 'toFahrenheit'", "Return type: float"],
            "test_cases": [
                {"input": "0", "expected_output": "32.0", "description": "Freezing point"},
                {"input": "100", "expected_output": "212.0", "description": "Boiling point"},
                {"input": "37.5", "expected_output": "99.5", "description": "Decimal precision check"}
            ],
            "reference_solution": "float toFahrenheit(float celsius) { return (celsius * 9.0 / 5.0) + 32.0; }",
            "grading_rubric": {
                "logic_points": 16,
                "syntax_points": 4,
                "hidden_deductions": [
                    {"condition": "Used integer division (9/5)", "deduct": 5, "exclusivity_group": "formula_error"},
                    {"condition": "Wrong formula logic", "deduct": 14, "exclusivity_group": "formula_error"},
                    {"condition": "Incorrect return type", "deduct": 2, "exclusivity_group": "syntax_error"}
                ]
            },
            "sample_answers": [
                {
                    "id": "L1_S1",
                    "label": "Integer Trap",
                    "human_score": 15,
                    "code": "float toFahrenheit(float c) { return (c * (9/5)) + 32; }",
                    "human_rationale": "Logic: 16 - 5 (integer division) = 11. Syntax: 4. Total: 15. The code is structurally perfect but fails math due to 9/5 evaluating to 1."
                },
                {
                    "id": "L1_S2",
                    "label": "Wrong Formula",
                    "human_score": 6,
                    "code": "float toFahrenheit(float c) { return (c * 5/9) + 32; }",
                    "human_rationale": "Logic: 16 - 14 (wrong formula) = 2. Syntax: 4. Total: 6. The student swapped the formula ratio."
                },
                {
                    "id": "L1_S3",
                    "label": "Wrong Return Type",
                    "human_score": 18,
                    "code": "int toFahrenheit(float c) { return (c * 9.0 / 5.0) + 32.0; }",
                    "human_rationale": "Logic: 16. Syntax: 4 - 2 (incorrect return type) = 2. Total: 18."
                }
            ]
        },
        {
            "id": "L2_EASY",
            "title": "Looping Logic (Factorial)",
            "total_points": 20,
            "problem_description": "Write a program that takes an integer N and prints the factorial of N.",
            "explicit_instructions": ["Use cin and cout"],
            "test_cases": [
                {"input": "5", "expected_output": "120", "description": "Standard factorial"},
                {"input": "0", "expected_output": "1", "description": "Edge case: 0!"},
                {"input": "13", "expected_output": "6227020800", "description": "Overflow check (requires long long)"}
            ],
            "reference_solution": "#include <iostream>\nusing namespace std;\nint main() {\n    int n; if (!(cin >> n) || n < 0) return 0;\n    long long fact = 1;\n    for(int i = 1; i <= n; i++) fact *= i;\n    cout << fact; return 0;\n}",
            "grading_rubric": {
                "logic_points": 16,
                "syntax_points": 4,
                "hidden_deductions": [
                    {"condition": "Used 'int' instead of 'long long'", "deduct": 2, "exclusivity_group": "data_type"},
                    {"condition": "Fails N=0 (result should be 1)", "deduct": 4, "exclusivity_group": "edge_case"},
                    {"condition": "Starts factorial at 0", "deduct": 12, "exclusivity_group": "math_logic"},
                    {"condition": "Loop starts from 0", "deduct": 12, "exclusivity_group": "math_logic"},
                    {"condition": "Loop condition incorrect (i < n)", "deduct": 4, "exclusivity_group": "loop_bounds"},
                    {"condition": "Prints result inside loop", "deduct": 3, "exclusivity_group": "io_format"},
                    {"condition": "Negative input not handled", "deduct": 1, "exclusivity_group": "validation"},
                    {"condition": "Fails to read input using cin", "deduct": 16, "exclusivity_group": "io_logic"}
                ]
            },
            "sample_answers": [
                 {
                   "id": "L2_S1",
                   "label": "Negative input not handled",
                   "human_score": 19,
                   "code": "#include <iostream>\nusing namespace std;\nint main() {\n    int n; cin >> n;\n    long long fact = 1;\n    for(int i = 1; i <= n; i++) fact *= i;\n    cout << fact;\n    return 0;\n}",
                   "human_rationale": "Logic: 16 - 1 (validation) = 15. Syntax: 4. Total: 19. Code works for all positive cases but doesn't handle negative inputs."
               },
                {
                    "id": "L2_S2",
                    "label": "Starts Factorial at 0",
                    "human_score": 8,
                    "code": "#include <iostream>\nusing namespace std;\nint main() {\n    int n; cin >> n; long long fact = 0; for(int i = 1; i <= n; i++) fact *= i; cout << fact; return 0;\n}",
                    "human_rationale": "Logic: 16 - 12 (math_logic) = 4. Syntax: 4. Total: 8. Initialization to 0 makes the result always 0."
                },
               {
                   "id": "L2_S3",
                   "label": "Loop off-by-one",
                   "human_score": 16,
                   "code": "#include <iostream>\nusing namespace std;\nint main() { int n; cin >> n; long long fact = 1; for(int i=1;i<n;i++) fact*=i; cout<<fact; return 0; }",
                   "human_rationale": "Logic: 16 - 4 (loop_bounds) = 12. Syntax: 4. Total: 16. Using 'i < n' instead of 'i <= n' misses the last multiplication."
                }
            ]
        },
        {
            "id": "L3_MEDIUM",
            "title": "String Manipulation (Palindrome)",
            "total_points": 20,
            "problem_description": "Write a function 'bool isPalindrome(string s)' (Case-sensitive).",
            "explicit_instructions": ["Case-sensitive", "Empty string = true"],
            "test_cases": [
                {"input": "\"racecar\"", "expected_output": "true", "description": "Standard palindrome"},
                {"input": "\"Racecar\"", "expected_output": "false", "description": "Case-sensitivity check"},
                {"input": "\"\"", "expected_output": "true", "description": "Empty string check"}
            ],
            "reference_solution": "#include <string>\n#include <algorithm>\nusing namespace std;\nbool isPalindrome(string s) {\n    if (s.empty()) return true;\n    string r = s; reverse(r.begin(), r.end());\n    return s == r;\n}",
            "grading_rubric": {
                "logic_points": 16,
                "syntax_points": 4,
                "hidden_deductions": [
                    {"condition": "Logic fails on odd-length strings", "deduct": 8, "exclusivity_group": "algorithm"},
                    {"condition": "Made it case-insensitive", "deduct": 4, "exclusivity_group": "instruction_violation"},
                    {"condition": "Does not handle empty string", "deduct": 3, "exclusivity_group": "edge_case"},
                    {"condition": "Off-by-one error in loop bounds", "deduct": 4, "exclusivity_group": "algorithm"},
                    {"condition": "Always returns false", "deduct": 16, "exclusivity_group": "algorithm"},
                    {"condition": "Wrong return type", "deduct": 2, "exclusivity_group": "syntax_error"}
                ]
            },
            "sample_answers": [
                {
                    "id": "L3_S2",
                    "label": "Off-by-One Error",
                    "human_score": 16,
                    "code": "bool isPalindrome(string s) {\n    int n = s.size();\n    for(int i = 0; i <= n/2; i++) {\n        if(s[i] != s[n - i - 1]) return false;\n    }\n    return true;\n}",
                    "human_rationale": "Logic: 16 - 4 (algorithm/off-by-one) = 12. Syntax: 4. Total: 16. The comparison 'i <= n/2' is slightly inefficient/wrong on the middle character comparison."
                }
            ]
        },
        {
            "id": "L4_HARD",
            "title": "Recursion (Fibonacci)",
            "total_points": 20,
            "problem_description": "Write a recursive function 'int fib(int n)'.",
            "explicit_instructions": ["Must use recursion", "No loops"],
            "test_cases": [
                {"input": "0", "expected_output": "0", "description": "Base case 1"},
                {"input": "1", "expected_output": "1", "description": "Base case 2"},
                {"input": "6", "expected_output": "8", "description": "Standard recursive step"}
            ],
            "reference_solution": "int fib(int n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n    return fib(n-1) + fib(n-2);\n}",
            "grading_rubric": {
                "logic_points": 16,
                "syntax_points": 4,
                "hidden_deductions": [
                    {"condition": "Missing base cases", "deduct": 10, "exclusivity_group": "instruction_violation"},
                    {"condition": "Used iterative loop", "deduct": 12, "exclusivity_group": "instruction_violation"},
                    {"condition": "Incorrect recursive relation", "deduct": 10, "exclusivity_group": "instruction_violation"},
                    {"condition": "Wrong return type", "deduct": 2, "exclusivity_group": "syntax_error"}
                ]
            },
            "sample_answers": [
                {
                    "id": "L4_S1",
                    "label": "Missing Base Case Trap",
                    "human_score": 10,
                    "code": "int fib(int n) {\n    return fib(n-1) + fib(n-2);\n}",
                    "human_rationale": "Logic: 16 - 10 (instruction_violation/missing base cases) = 6. Syntax: 4. Total: 10. Math logic is there, but implementation causes stack overflow."
                },
                {
                    "id": "L4_S2",
                    "label": "Perfect Recursive Solution",
                    "human_score": 20,
                    "code": "int fib(int n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n    return fib(n-1) + fib(n-2);\n}",
                    "human_rationale": "Logic: 16. Syntax: 4. Total: 20. Perfectly followed all recursive instructions."
                },
                {
                    "id": "L4_S3",
                    "label": "Iterative Violation",
                    "human_score": 8,
                    "code": "int fib(int n) {\n    int a = 0, b = 1, c;\n    if(n==0) return 0;\n    for(int i=2; i<=n; i++) {\n        c = a + b; a = b; b = c;\n    }\n    return b;\n}",
                    "human_rationale": "Logic: 16 - 12 (instruction_violation/used loop) = 4. Syntax: 4. Total: 8. The math is correct, but failed the 'No loops' constraint."
                },
                {
                    "id": "L4_S4",
                    "label": "Formula Error",
                    "human_score": 10,
                    "code": "int fib(int n) {\n    if (n <= 1) return n;\n    return fib(n-1) + fib(n-1);\n}",
                    "human_rationale": "Logic: 16 - 10 (instruction_violation/incorrect relation) = 6. Syntax: 4. Total: 10. Student used recursion but used the wrong mathematical formula."
                }
            ]
        },
        {
            "id": "L5_VERY_HARD",
            "title": "Memory Safety (Linked List)",
            "total_points": 20,
            "problem_description": "Write a function 'Node* insertEnd(Node* head, int value)' to append a node.",
            "explicit_instructions": ["Return new head", "Use dynamic memory (new)"],
            "test_cases": [
                {"input": "head=NULL, val=10", "expected_output": "New node with 10", "description": "Empty list handling"},
                {"input": "head=[5], val=15", "expected_output": "[5, 15]", "description": "Existing list append"}
            ],
            "reference_solution": "struct Node { int data; Node* next; };\nNode* insertEnd(Node* head, int val) {\n    Node* nn = new Node{val, nullptr};\n    if(!head) return nn;\n    Node* t = head; while(t->next) t = t->next;\n    t->next = nn; return head;\n}",
            "grading_rubric": {
                "logic_points": 16,
                "syntax_points": 4,
                "hidden_deductions": [
                    {"condition": "Crash when head is NULL", "deduct": 6, "exclusivity_group": "safety"},
                    {"condition": "Memory allocation failure", "deduct": 16, "exclusivity_group": "allocation"},
                    {"condition": "Does not return new head", "deduct": 5, "exclusivity_group": "signature"},
                    {"condition": "Fails to use 'new' for node creation", "deduct": 12, "exclusivity_group": "allocation"},
                    {"condition": "Memory leak/Lost pointer", "deduct": 6, "exclusivity_group": "safety"},
                    {"condition": "Infinite loop", "deduct": 14, "exclusivity_group": "safety"}
                ]
            },
            "sample_answers": [
                {
                    "id": "L5_S1",
                    "label": "Null Head Crash Trap",
                    "human_score": 14,
                    "code": "Node* insertEnd(Node* head, int v) {\n    Node* temp = head;\n    while(temp->next != nullptr) temp = temp->next;\n    temp->next = new Node(v);\n    return head;\n}",
                    "human_rationale": "Logic: 16 - 6 (safety/crash on null) = 10. Syntax: 4. Total: 14. Missing the empty list check causes a null pointer dereference."
                },
                {
                    "id": "L5_S2",
                    "label": "Perfect Solution",
                    "human_score": 20,
                    "code": "Node* insertEnd(Node* head, int val) {\n    Node* nn = new Node{val, nullptr};\n    if(!head) return nn;\n    Node* t = head; \n    while(t->next) t = t->next;\n    t->next = nn; \n    return head;\n}",
                    "human_rationale": "Logic: 16. Syntax: 4. Total: 20. Code is memory safe and correct."
                },
                {
                    "id": "L5_S3",
                    "label": "Wrong Return Contract",
                    "human_score": 15,
                    "code": "Node* insertEnd(Node* head, int val) {\n    Node* nn = new Node{val, nullptr};\n    if(!head) return nn;\n    Node* t = head; while(t->next) t = t->next;\n    t->next = nn;\n    return nn; \n}",
                    "human_rationale": "Logic: 16 - 5 (signature/does not return head) = 11. Syntax: 4. Total: 15. The function correctly appends but returns the new node instead of the head."
                }
            ]
        }
    ]
}